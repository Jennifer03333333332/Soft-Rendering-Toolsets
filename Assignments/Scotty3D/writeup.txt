For checkpoint:

Fully implemented Task1，2;


Task1

Spline::cubic_unit_spline()
	evaluates a spline defined over the time interval [0,1] given a pair of endpoints and tangents at endpoints.

Task 1B: Evaluation of a Catmull-Rom spline
Make Hermite Curve from interpolation between 2 points，to smooth splines between a sequence of points
	Task: find the interval closest to the query time, and evaluate its endpoints and tangents.
Spline::at()
	evaluates a general Catmull-Romspline at the specified time in a sequence of points (called “knots”).

Attention：when calling Spline::cubic_unit_spline()，t need to be normalized to [0,1]（divide by the length of the current interval）
A transformation is necessary for both the tangents that you feed in to specify the unit spline. 

Spline: <knot time, knot values>
use map::upper_bound() 

My error: thought lower_bound() means the < value to current value. actually it's >=

Task2
step_ik:
  in each frame:
	loop the joint and target in active_handles
		(one joint could be used in many IK_Handle)
		call compute_gradient, attention: need to compute_gradient upward until reach the root
	then for all joints 
		rotate a little bit
		clean the gradient

compute_gradient:
	compute Jacobian for each axies, each joints
	add to gradients
	iterate upward until reach the root