For checkpoint:

Fully implemented Task1，2;


Task1

Spline::cubic_unit_spline()
	evaluates a spline defined over the time interval [0,1] given a pair of endpoints and tangents at endpoints.

Task 1B: Evaluation of a Catmull-Rom spline
Make Hermite Curve from interpolation between 2 points，to smooth splines between a sequence of points
	Task: find the interval closest to the query time, and evaluate its endpoints and tangents.
Spline::at()
	evaluates a general Catmull-Romspline at the specified time in a sequence of points (called “knots”).

Attention：when calling Spline::cubic_unit_spline()，t need to be normalized to [0,1]（divide by the length of the current interval）
A transformation is necessary for both the tangents that you feed in to specify the unit spline. 

Spline: <knot time, knot values>
use map::upper_bound() 

My error: thought lower_bound() means the < value to current value. actually it's >=

Task2
step_ik:
  in each frame:
	loop the joint and target in active_handles
		(one joint could be used in many IK_Handle)
		call compute_gradient, attention: need to compute_gradient upward until reach the root
	then for all joints 
		rotate a little bit
		clean the gradient

compute_gradient:
	compute Jacobian for each axies, each joints
	add to gradients
	iterate upward until reach the root

Task3: Linear Blend skinning

In Skeleton::find_joints
	Build a map, stores <vertex's index, a list of Joint* that could effect this vertex>
		How to judge this joint should effect this vertex:closest_on_line_segment()
			find it's closest point on this line segment
			Judge (verts[i].pos - projection point).norm() <= j->radius

In closest_on_line_segment
	 Return the closest point to 'point' on the line segment from start to end

In Skeleton::skin
	After build the map in Skeleton::find_joints
	for each vertex's joints'
		calculate dist_ij in joint space
		store to calculate this weighted combination
		v_ij is the posed position in world space

Task4: Particles

bool Particle::update(const PT::BVH<PT::Object>& scene, float dt, float radius)
	float remain_timestep = dt;
	while(remain_timestep > 0)
		Create Ray ,call hit(ray), 
		Calculate the hit point - interval
		Notice: Surface normal could be in 2 ways
			cos_theta could < 0
			radius / interval = cos_theta
		When not hit or hit_time > remain time step or cos_theta == 0
			x = x+ v*remain time step; v = v+a*remain time step
		Else hit
			reflect the velocity
			remain time step -= hit_time
	age-=dt;
    	return age > 0;