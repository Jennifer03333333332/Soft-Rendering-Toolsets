AndrewID: yingxual

Task 1:
    Fully implemented.
    glBegin and glEnd will basically define how vertices made inside of this will be interpreted.
    glColor3f() mush be put before other actions
    
Task 2:
    Fully implemented.
    Using Bresenham's algorithm to implement drawing lines, then usexiaolinwu algorhitm based on the code in wiki
    Code: SoftwareRendererImp::rasterize_line_Bresenham() and SoftwareRendererImp::rasterize_line_xiaolinwu()
    

Task 3:
    Fully implemented.
    Using SoftwareRendererImp::inside_triangle() to judge if point p is inside the triangle or not. 
    Using a 2D-bounding box.
    Could judge counter-clockwise and clockwise for vertices.
    Covered points on the triangles' edge

Task 4:

    Fully implemented SuperSampling Anti-Aliasing(SSAA)
    
    Steps:
    //1 Have render_target already. Create a new super_sample_buffer. the length would be rate*rate times than render_target
    //2 Rasterize based on super_sample_buffer
    //3 Resolve it to render_target
    
    To solve the 'lines get thinner' problem, points and lines shouldn't attend SSAA.
    I make them more thick in super_sample_buffer
    
    Problems I faced:
    Faced with many problems with float type and uint8_t type precision
    Change the data structure a lot, super_sample_buffer from unsigned char array to vector<uint8_t>, then to vector<float>


Task 5:

    Fully implemented.
    5a:
    SVGRenderer.transformation transform object coordinate to screen coordinate
    Before this transform we need to do model transform
    Implement in draw_element()
    5b:
    This function should construct a Matrix3x3 object (Homogenous coordinate for 2D) that transforms the viewport area to normalized screen space.
    first move to origin, then scale, then translate to (0.5,0.5)

Task 6:

    Fully implemented.
    Finish SoftwareRendererImp::rasterize_image, Sampler2DImp::sample_nearest | sample_bilinear | sample_trilinear
    In rasterize_image(), rasterize the image element to each point, then map it to (u,v), then get the color by those sample2dImp functions
    Using supersampling
    Thoughts: need reading the struct miplevel and texture
    Color Sampler2DImp::sample_bilinear(Texture& tex, float u, float v, int level) {
    if (level < 0 || level >= tex.mipmap.size()) return Color(1, 0, 1, 1); 
    float su = clamp(u, 0.0f, 0.99f) * tex.mipmap[level].width; 
    float sv = clamp(v, 0.0f, 0.99f) * tex.mipmap[level].height;

    float u0 = floor(su) + 0.5f; float v0 = floor(sv) + 0.5f;
    float u1, v1;
    if (round(su) == (int)su) {//su-(int)su <0.5
        u1 = clamp<float>(floor(su) - 1.0 + 0.5f, 0.0, tex.mipmap[level].width);//if out of range : constrain
        swap(u1, u0);
    }
    else { u1 = clamp<float>(ceil(su) + 0.5f, 0.0, tex.mipmap[level].width); }
    if (round(sv) == floor(sv) - 1.0 + 0.5f) {
        v1 = clamp<float>((int)sv - 1, 0.0, tex.mipmap[level].height);
        swap(v1, v0);
    }
    else { v1 = clamp<float>(ceil(sv) + 0.5f, 0, tex.mipmap[level].height); }
    Color lerpHorizontal1 = lerpColor((su - u0) / (u1 - u0), GetColorFromTexure(tex, level, u0, v0), GetColorFromTexure(tex, level, u1, v0)); 
    Color lerpHorizontal2 = lerpColor((su - u0) / (u1 - u0), GetColorFromTexure(tex, level, u0, v1), GetColorFromTexure(tex, level, u1, v1)); 
    Color lerpVertical = lerpColor((sv - v0) / (v1 - v0), lerpHorizontal1, lerpHorizontal2);
    return lerpVertical;
}

Task 7:

    Fully implemented.

Task 8:

    Fully implemented.

Extra credit:

    I completed the following extra credit work... (or N/A)

    For Task2, I did rasterize_line_xiaolinwu

Any other comments and considerations:

    ....