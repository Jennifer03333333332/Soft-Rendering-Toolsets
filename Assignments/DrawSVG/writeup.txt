AndrewID: yingxual

Task 1:
    Fully implemented.
    glBegin and glEnd will basically define how vertices made inside of this will be interpreted.
    glColor3f() mush be put before other actions
    
Task 2:
    Fully implemented.
    Using Bresenham's algorithm to implement drawing lines, then usexiaolinwu algorhitm based on the code in wiki
    Code: SoftwareRendererImp::rasterize_line_Bresenham() and SoftwareRendererImp::rasterize_line_xiaolinwu()
    

Task 3:
    Fully implemented.
    Using SoftwareRendererImp::inside_triangle() to judge if point p is inside the triangle or not. 
    Using a 2D-bounding box.
    Could judge counter-clockwise and clockwise for vertices.
    Covered points on the triangles' edge

Task 4:

    Fully implemented SuperSampling Anti-Aliasing(SSAA)
    
    Steps:
    //1 Have render_target already. Create a new super_sample_buffer. the length would be rate*rate times than render_target
    //2 Rasterize based on super_sample_buffer
    //3 Resolve it to render_target
    
    To solve the 'lines get thinner' problem, points and lines shouldn't attend SSAA.
    I make them more thick in super_sample_buffer
    
    Problems I faced:
    Faced with many problems with float type and uint8_t type precision
    Change the data structure a lot, super_sample_buffer from unsigned char array to vector<uint8_t>, then to vector<float>


Task 5:

    Fully implemented.
    5a:
    SVGRenderer.transformation transform object coordinate to screen coordinate
    Before this transform we need to do model transform
    Implement in draw_element()
    5b:
    This function should construct a Matrix3x3 object (Homogenous coordinate for 2D) that transforms the viewport area to normalized screen space.
    first move to origin, then scale, then translate to (0.5,0.5)

Task 6:

    Fully implemented.
    Finish SoftwareRendererImp::rasterize_image, Sampler2DImp::sample_nearest | sample_bilinear | sample_trilinear
    In rasterize_image(), rasterize the image element to each point, then map it to (u,v), then get the color by those sample2dImp functions
    Using supersampling
    Thoughts: need reading the struct miplevel and texture
Task 7:

    Fully implemented.

Task 8:

    Fully implemented.

Extra credit:

    I completed the following extra credit work... (or N/A)

    For Task2, I did rasterize_line_xiaolinwu

Any other comments and considerations:

    ....